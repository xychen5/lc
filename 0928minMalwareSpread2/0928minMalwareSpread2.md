## 0928 minMalwareSpread 最少病毒传播

### 1 题目
[https://leetcode-cn.com/problems/minimize-malware-spread-ii/](https://leetcode-cn.com/problems/minimize-malware-spread-ii/)

### 2 解题思路
个人体悟： 当需要判断两个节点是否位于同一个连通子图时，首选并查集

- 1 普通思路1
  - 1.1 使用dfs，对于每个initial，则计算仅仅由他能传播到的节点有多少
- 2 使用并查集：
  -  明确目标：对于每个initial，则计算仅仅由他能传播到的节点有多少
  -  那么就首先构造不含initial的一个图G
  -  遍历initial中的每个顶点，那么G中每个root都可以知道会被哪些initial所影响
  -  于是每个initial的贡献为仅仅被自己所连接的root（也就是仅由自己才能传播过去）（换句话说，若G中的一个连通子图，会被好几个initial传播，那么只删除一个initial是没办法改变这个联通子图会被传播的下场）

```cpp
class Solution {
public:
    int find(vector<int>& parent, int x) {
        while(x != parent[x]) {
            parent[x] = parent[parent[x]];
            x = parent[x];
        }
        return x;
    }

    bool unionMerge(vector<int>& parent, vector<int>& subTreeSize, int x, int y) {
        int findX = find(parent, x);
        int findY = find(parent, y);
        if(findX != findY) {
            parent[findX] = findY;
            subTreeSize[findY] += subTreeSize[findX];
            return true;
        }
        return false;
    }


    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        // 对于每个initial计数的方式发生了改变，考虑一个不含有inital 的图，initial的得分应该是单独被他影响的子集
        int n = graph.size();
        vector<int> parent(n);
        for(int i = 0; i < n; ++i) {
            parent[i] = i;
        }
        
        vector<bool> isInitial(n, false);
        for(auto& i : initial) {
            isInitial[i] = true;
        }

        vector<int> subTreeSize(n, 1);
        // 构造union find set
        for(int i = 0; i < n; ++i) {
            if(isInitial[i]) {
                continue;
            }
            for(int j = 0; j < n; ++j) {
                if(1 == graph[i][j] && !isInitial[j]) {
                    unionMerge(parent, subTreeSize, i, j);
                }
            }
        }

        // for(int i = 0; i < n; ++i) {
        //     cout << "root " << i << " -> size " << subTreeSize[i] << endl;
        // }
        
        // find componets infected by a initial
        unordered_map<int, unordered_set<int>> initialToComponents;
        unordered_map<int, int> rootToInitial;
        for(auto& i : initial) {
            unordered_set<int> components;
            for(int v = 0; v < n; ++v) {
                if(!isInitial[v]) {
                    if(graph[i][v] == 1) {
                        int root = find(parent, v);
                        components.insert(root);
                        // cout << " ||| " << i << " >> " << root << endl;
                        // no occupied by single initial
                        if(rootToInitial.find(root) != rootToInitial.end() && \
                        rootToInitial[root] != i) {
                            rootToInitial[root] = -1;
                            continue;
                        }
                        rootToInitial[root] = i;
                    }
                }
            }
            initialToComponents[i] = components;
        }


        // cal scores for each initial
        int resInit = INT_MAX;
        int maxScore = INT_MIN;
        for(auto& p : initialToComponents) {
            int curInit = p.first;
            unordered_set<int> components = p.second;
            int score = 0;
            for(auto& root : components) {
                // std::cout << curInit << " -> " << score  << " with com: " << root << endl;
                if(rootToInitial[root] != -1) {
                    score += subTreeSize[root];
                    // cout << "added!" << endl;
                }
            }
            if(score > maxScore || (score == maxScore && curInit < resInit)) {
                maxScore = score;
                resInit = curInit;
            }
        }

        return resInit;
    }
};
```
